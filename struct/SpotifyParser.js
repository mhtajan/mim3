const fetch = require("node-fetch-commonjs");
const { URLSearchParams } = require("url");
const BASE_URL = "https://api.spotify.com/v1";
class SpotifyParser {
  nodes;
  authorization;
  token;
  options;
  /**
   * A class to convert Spotify URLs into Lavalink track objects.
   * @param {Node} Node A lavalink node to expose the lavalink API
   * @param {string} clientID Your Spotify's client ID.
   * @param {string} clientSecret Your Spotify's client secret.
   */
  constructor(LavalinkNode, clientID, clientSecret) {
    this.nodes = LavalinkNode;
    this.authorization = Buffer.from(`${clientID}:${clientSecret}`).toString("base64");
    this.token = "";
    this.options = {
      headers: {
        "Content-Type": "application/json",
        Authorization: this.token
      }
    };
    this.renew();
  }
  /**
   * Fetch the tracks from the album and return the SpotifyTrack or LavalinkTrack objects.
   * @param {string} id The album ID.
   * @param {boolean} convert Whether to return results as LavalinkTrack objects instead of SpotifyTrack objects.
   * @param {FetchOptions} fetchOptions An object containing the options for fetching Lavalink tracks with the Spotify tracks.
   * @returns {Promise<LavalinkTrack[]|SpotifyTrack[]>} The promisified array of the tracks in the album, in the form of a Lavalink Track object (if converted) or a Spotify Track object.
   */
  async getAlbumTracks(id, convert = false, fetchOptions) {
    if (!id) throw new ReferenceError("The album ID was not provided");
    if (typeof id !== "string") throw new TypeError(`The album ID must be a string, received type ${typeof id}`);
    const {
      items
    } = await (await fetch(`${BASE_URL}/albums/${id}/tracks`, this.options)).json();
    if (convert) return Promise.all(items.map(async item => await this.fetchTrack(item, fetchOptions)));
    return items;
  }
  /**
   * Fetch the tracks from the album and return the SpotifyTrack or LavalinkTrack objects.
   * @param {string} id The album ID.
   * @param {boolean} convert Whether to return results as LavalinkTrack objects instead of SpotifyTrack objects.
   * @param {FetchOptions} fetchOptions An object containing the options for fetching Lavalink tracks with the Spotify tracks.
   * @returns {Promise<LavalinkTrack[]|SpotifyTrack[]>} The promisified array of the tracks in the playlist, in the form of a Lavalink Track object (if converted) or a Spotify Track object.
   */
  async getPlaylistTracks(id, convert = false, fetchOptions) {
    if (!id) throw new ReferenceError("The playlist ID was not provided");
    if (typeof id !== "string") throw new TypeError(`The playlist ID must be a string, received type ${typeof id}`);
    const playlistInfo = await (await fetch(`${BASE_URL}/playlists/${id}`, this.options)).json();
    const sets = Math.ceil(playlistInfo.tracks.total / 50);
    let items = [];
    for (let set = 0; set < sets; set++) {
      const params = new URLSearchParams();
      params.set("limit", "50");
      params.set("offset", String(set * 50));
      const tracks = await (await fetch(`${BASE_URL}/playlists/${id}/tracks?${params}`, this.options)).json();
      items = items.concat(tracks.items.map(item => item.track));
      if (set === 0) items.unshift();
    }
    if (convert) return Promise.all(items.map(async item => await this.fetchTrack(item, fetchOptions)));
    return items;
  }
  /**
   * Fetch the tracks from the album and return the SpotifyTrack or LavalinkTrack objects.
   * @param {string} id The album ID.
   * @param {boolean} convert Whether to return results as LavalinkTrack objects instead of SpotifyTrack objects.
   * @param {FetchOptions} fetchOptions An object containing the options for fetching Lavalink tracks with the Spotify tracks.
   * @returns {Promise<LavalinkTrack|SpotifyTrack>} The promisified Lavalink Track object (if converted) or the Spotify Track object.
   */
  async getTrack(id, convert = false, fetchOptions) {
    if (!id) throw new ReferenceError("The track ID was not provided");
    if (typeof id !== "string") throw new TypeError(`The track ID must be a string, received type ${typeof id}`);
    const track = await (await fetch(`${BASE_URL}/tracks/${id}`, this.options)).json();
    if (convert) return this.fetchTrack(track, fetchOptions);
    return track;
  }
  /**
   * Return a LavalinkTrack object from the SpotifyTrack object.
   * @param {SpotifyTrack} track The SpotifyTrack object to be searched and compared against the Lavalink API
   * @param {FetchOptions} fetchOptions An object containing the options for fetching Lavalink tracks with the Spotify tracks.
   * @returns {Promise<LavalinkTrack|null>} The promisified Lavalink Track object, or null if no match found.
   */
  async fetchTrack(track, fetchOptions = {
    autoGeneratedOnly: true,
    prioritizeSameDuration: false,
    customFilter: () => true,
    customSort: () => 0
  }) {
    if (!track) throw new ReferenceError("The Spotify track object was not provided");
    if (!track.artists) throw new ReferenceError("The track artists array was not provided");
    if (!track.name) throw new ReferenceError("The track name was not provided");
    if (!Array.isArray(track.artists)) throw new TypeError(`The track artists must be an array, received type ${typeof track.artists}`);
    if (typeof track.name !== "string") throw new TypeError(`The track name must be a string, received type ${typeof track.name}`);
    const title = `${track.name} ${track.artists[0].name} ${fetchOptions.autoGeneratedOnly ? " description:(\"Auto-generated by YouTube.\")" : ""}`;
    const params = new URLSearchParams();
    params.append("identifier", `ytsearch: ${title}`);
    const {
      host,
      port,
      password
    } = this.nodes;
    const {
      tracks
    } = await (await fetch(`http://${host}:${port}/loadtracks?${params}`, {
      headers: {
        Authorization: password
      }
    })).json();
    if (!tracks.length) return null;
    if (fetchOptions.prioritizeSameDuration) {
      const sameDuration = tracks.filter(searchResult => searchResult.info.length >= track.duration_ms - 1500 && searchResult.info.length <= track.duration_ms + 1500)[0];
      if (sameDuration) return sameDuration;
    }
    if (typeof fetchOptions.customFilter === "undefined") fetchOptions.customFilter = () => true;
    if (typeof fetchOptions.customSort === "undefined") fetchOptions.customSort = () => 0;
    return tracks.filter(searchResult => fetchOptions.customFilter(searchResult, track)).sort((comparableTrack, compareToTrack) => fetchOptions.customSort(comparableTrack, compareToTrack, track))[0];
  }
  async renewToken() {
    const {
      access_token,
      expires_in
    } = await (await fetch("https://accounts.spotify.com/api/token", {
      method: "POST",
      body: "grant_type=client_credentials",
      headers: {
        Authorization: `Basic ${this.authorization}`,
        "Content-Type": "application/x-www-form-urlencoded"
      }
    })).json();
    if (!access_token) throw new Error("Invalid Spotify client.");
    this.token = `Bearer ${access_token}`;
    this.options.headers.Authorization = this.token;
    // Convert expires_in into ms
    return expires_in * 1000;
  }
  async renew() {
    setTimeout(this.renew.bind(this), await this.renewToken());
  }
}
module.exports = SpotifyParser;